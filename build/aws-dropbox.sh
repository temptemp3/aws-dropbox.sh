#!/bin/bash
## aws-dropbox
## version 0.0.1 - initial
##################################################
#!/bin/bash
## cecho
## - color echo
## version 0.1.0 - add color magenta as pink
##################################################
cecho-color() { #{ local candidate_color ; candidate_color="${1}" ; }
 case ${candidate_color} in
  pink) {
   echo 35
  } ;;
  blue) {
   echo 34 
  } ;;
  yellow) {
   echo 33
  } ;;
  green) {
   echo 32 
  } ;; 
  *) {
   echo 0
  } ;;
 esac
}
#-------------------------------------------------
cecho() { { local candidate_color ; candidate_color="${1}" ; local line ; line=${@:2} ; }
  test ! "${line}" || {
    echo -e "\e[$( ${FUNCNAME}-color )m ${line} \e[0m" 
  } 1>&2
}
##################################################
#!/bin/bash
## commands (alias)
## - function command cli adapter
## version 0.0.6 - enable alias expansion for standalone use
##################################################
list-available-commands() { { local function_name ; function_name="${1}" ; local filter_include ; filter_include="${2}" ; }
 echo available commands:
 declare -f \
   | grep -e "^${function_name}" \
   | cut "-f1" "-d " \
   | grep -v -e "which" -e "for-each" -e "payload" -e "initialize" \
   | sed -e "s/${function_name}-//" \
   | xargs -I {} echo "- {}" \
   | sed  "1d" \
   | grep -e "${filter_include}"
}
shopt -s expand_aliases
alias read-command-args='
 list-available-commands ${FUNCNAME}
 echo "enter new command (or q to quite)"
 read command_args
'
alias parse-command-args='
 _car() { echo ${1} ; }
 _cdr() { echo ${@:2} ; }
 _command=$( _car ${command_args} )
 _args=$( _cdr ${command_args} )
'
alias commands='
 #test "${_command}" || { local _command ; _command="${1}" ; }
 #test "${_args}" || { local _args ; _args=${@:2} ; }
 { local _command ; _command="${1}" ; }
 { local _args ; _args=${@:2} ; }
 test ! "$( declare -f ${FUNCNAME}-${_command} )" && {
  {    
    test ! "${_command}" || {
     echo "${FUNCNAME} command \"${_command}\" not yet implemented"
    }
    list-available-commands ${FUNCNAME} 
  } 1>&2
 true
 } || {
  ${FUNCNAME}-${_command} ${_args}
 }
'
alias run-command='
 {
   commands
 } || true
'
alias handle-command-args='
 case ${command_args} in
   q|quit) {
    break  
   } ;; 
   *) { 
    parse-command-args
   } ;;
 esac
'
alias command-loop='
 while [ ! ]
 do
  run-command
  read-command-args
  handle-command-args
 done
'
##################################################
#!/bin/bash
## build
## - builds a copy of script with resolved . lines
## version 0.0.4 - if output enabled obfuscate
##################################################
build() {
  local outfile
  outfile="${build}/$( basename ${0} .sh )"
  cecho green "building standalone ..."
  ################################################
  ## 1.  cleanup build (creates empty build dir)
  ## 1.  populate build (minimum: source script)
  ## 1.1 migrate script
  ################################################
  ## 1. cleanup build (creates empty build dir)
  ################################################
  cecho green "cleanup up build ..."
  cecho yellow $( test ! -d "${build}" || rm -rvf ${_} )
  cecho yellow $( mkdir -v "${build}" )
  cecho green "build clean"
  ################################################
  ## 1. populate build (minimum: source script)
  ################################################
  ## 1.1 migrate script
  ## - resolves '.' lines
  ## - keeps 'source' lines
  ################################################
  { # resolve source lines
    bash -vp ${0} true 2>&1 | 
    grep -v -e '^\s*[.]\s\+' 
  } | tee ${outfile}.sh
  ################################################
  ## obfuscate output to prevent easy tampering
  ################################################
  test ! "${do_obfuscate}" || {
    test ! $( which bash-obfuscate 2>/dev/null ) || {
      bash-obfuscate ${outfile}.sh > ${outfile}.sh-temp
      mv -v ${outfile}.sh{-temp,}
    }
  }
  ################################################
  cecho green "standalone built"
}
##################################################
## generated by create-stub2.sh v0.1.2
## on Sat, 04 May 2019 11:57:45 +0900
## see <https://github.com/temptemp3/sh2>
##################################################
rate-s3() {
  echo 0.025
}
rate-glacier() {
  echo 0.005
}
rate() {
  commands
}
template-cost-summary() {
  cat << EOF
MONTHLY COST
all in s3: ${cost_monthly_s3} USD/Mo
all in glacier: ${cost_monthly_glacier} USD/Mo
hybrid: ${cost_monthly_hybrid} USD/Mo

YEARLY COST
all in s3: ${cost_yearly_s3} USD/Yr
all in glacier: ${cost_yearly_glacier} USD/Yr
hybrid: ${cost_yearly_hybrid} USD/Yr
EOF
}
template() {
  commands
}
aws-dropbox-main() {
  local candidate_storage
  local -i storage
  read -p "How much space do you need? " candidate_storage
  storage=$(
  case ${candidate_storage} in
   *T) echo $((${candidate_storage//T/}*1024)) ;;
   *G) echo $((${candidate_storage//G/}*1)) ;;
   *)  echo 0
  esac
  )
  test ! ${storage} -gt 0 && return
  echo ok
  cost_monthly_s3=$( gawk "BEGIN { print ${storage} * $( rate s3 ) }" )
  cost_monthly_glacier=$( gawk "BEGIN { print ${storage} * $( rate glacier ) }" )
  cost_monthly_hybrid=$( gawk "BEGIN { print .80 * ${storage} * $( rate s3 ) + .20 * ${storage} * $( rate glacier ) }" )
  cost_yearly_s3=$( gawk "BEGIN { print 12 * ${cost_monthly_s3} }" )
  cost_yearly_glacier=$( gawk "BEGIN { print 12 * ${cost_monthly_glacier} }" )
  cost_yearly_hybrid=$( gawk "BEGIN { print 12 * ${cost_monthly_hybrid} }" )
  template cost-summary
}
aws-dropbox-build() {
  build=build
  build true
}
aws-dropbox-true() {
  true
}
aws-dropbox() {
  commands
}
##################################################
if [ ! ] 
then
 true
else
 exit 1 # wrong args
fi
##################################################
aws-dropbox ${@}
##################################################
## generated by create-stub2.sh v0.1.2
## on Mon, 14 Oct 2019 08:24:43 +0900
## see <https://github.com/temptemp3/sh2>
##################################################
